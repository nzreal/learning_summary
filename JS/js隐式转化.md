# JS == 与 === 及隐式转化

开头整活

<div  align="center">
 <img src="../image/PatrickStar.jpeg" width = "500" height = "700" alt="图片名称" />
 <p style="color: #e7e7e7">派大星牌编译器</p>
</div>
众所周知，之所以大家现在写 js === 去判断等号两端参数是否相等，是因为 js 的 == 实在过于 emmm...

先来说说 == 与 === 的共同点，都会先判断类型再比较值，如果是基础值（如： number，string）

若是引用值时则会比较其引用

不同的则是 === 是强等，当前后参数类型不同直接返回 false，而 == 在遇到该情况时会对参数进行隐式转化

## 隐式转化

我们先来说说隐式转化

在 js 中，当运算符在运算时，如果两边数据不统一，CPU 就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算

这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换

例如 1 > "0"这行代码在 js 中并不会报错，编译器在运算符时会先把右边的"0"转成数字 0 然后再比较大小

1. 转成 string、number 类型： +（字符串连接符）（当操作符前后参数类型不一致时）
2. 转成 number 类型：++/--(自增自减运算符) + - \* / %(算术运算符) > < >= <= == != === !=== (关系运算符)
3. 转成 boolean 类型：!（逻辑非运算符）

### 转化规则

<div  align="center">
 <img src="../image/rule.png" width = "500" height = "300" alt="图片名称" />
 <p style="color: #e7e7e7">隐式转化规则</p>
</div>

当用 == 去比较不同类型的参数时 参数会一直转化类型直到类型相同再比较

好的，看到这里大家会有点懵，那我们就来复盘一下“派大星”处理的那一系列代码

```js
console.log(0 == '0') // true
console.log(0 == []) // true
console.log('0' == []) // false
```

第一个 0 == '0' 很简单，左侧 0 类型为 number ，处于隐式转化类型底层，所以只需把右侧转化为 number 比较即可，'0' 向下调用 Number('0')转化为 0， 所以 0 == 0 结果为 true

第二个 0 == []，同样需要将 [] 转化为 number 类型，这时有两层需要转化，array => string => number，先调用 valueOf()获取原始值 [], 然后调用 toString() 方法，结果为 '' （一开始看到不是'[]'），我表示震惊，然后需要将 '' 转化为 number，调用 Number() 结果为 0，0 == 0 结果为 true

第三个 '0' == []，左侧 '0' 类型为 string ，所以只需将右侧的 array 转化为 string 比较即可，
[] 的转化同上为 '' 这时类型一致就可以比较啦，可以 '0' 和 '' ，一看就不相等。。。结果为 false

这样一下大家就知道隐式转化规则有多坑了把。。。

同时这里列一个隐式转化规则常用表

|     value     | Number() |  toString/String()   | Boolean() |
| :-----------: | :------: | :------------------: | :-------: |
|       0       |    0     |         '0'          |   false   |
|       1       |    1     |         '1'          |   true    |
|      ''       |    0     |          ''          |   false   |
|     '123'     |   123    |        '123'         |   true    |
|      {}       |   NaN    |  '[object Object]'   |   true    |
|   {a: 123}    |   NaN    |  '[object Object]'   |   true    |
|      []       |    0     |          ''          |   true    |
|      [2]      |    2     |         '2'          |   true    |
|   [1, 2, 3]   |   NaN    |      '1, 2, 3'       |   true    |
|  [3, [1, 2]]  |   NaN    |      '3, 1, 2'       |   true    |
| [3, {a: 123}] |   NaN    | '3, [object Object]' |   true    |
|     null      |    0     |        'null'        |   false   |
|   undefined   |   NaN    |     'undefined'      |   false   |

基本上是罗列了大部分常用的一些隐式转化的结果，至于结果为何大家可以参照前面的转化规则一条一条过

然后如 Map，Set, Promise 对象基本与对象无异只不过 toString() 后，如 Map 为'[object Map]'，以此类推
