#逻辑运算符


###1.&& 逻辑与

a && b

运算逻辑:

a && b, 若 a 为 false 则返回 a, 若 a 为 true 则返回 b

```js
 console.log(3 && 1) // 1
 console.log(0 && 1) // 0 
 // ps: 0为false
 ```
总结：假前真后

###2.|| 逻辑或

a || b

运算逻辑:

a || b, 若 a 为 false 则返回 b, 若 a 为 true 则返回 a

```js
console.log(3 || 1) // 3
console.log(0 || 1) // 1
console.log('' || true) // true
// ps: ''空字符串在js中也会被判定为false
console.log(!!'') // false
```
总结：真前假后

###3.! 逻辑非

!a

运算逻辑:

若 a 为 true, 则返回 false, 反之亦然

```js
console.log(!1) // false
```

若要显式的返回变量的布尔值则可以使用 !! 双重非运算符 来运算

```js
console.log(!!1) // true
console.log(!!0) // false
```

需要注意的是在JS中会被转换为 false 的表达式有:

+ null
+ undefined
+ NaN
+ 0
+ 空字符串（"" or '' or ``)


总结: 取反

#位运算符

>其实位运算符是所有语言通用的运算符，偷懒起见还是写在了JS分类下哈哈哈

>位运算符都需要将运算符前后的数转为二进制再运算, 所谓的位是二进制数的位数

###1.| 按位或运算符

a | b

运算规则：

0|0=0；0|1=1；1|0=1；1|1=1；即: a 和 b 的对应二进制位只要有一个为1，其值为1。

```js
console.log(3 | 4) // 7
// 3转为二进制0011, 4转为二进制0100, 所以结果为0111, 输出7
console.log(31 | 2) // 31
// 31 -> 00011111 2 -> 00000010, 结果为00011111, 输出31
```

实际应用:

可用于小数取整

```js
//后面为0时取小于该小数的最大整数
console.log(3.1 | 0) // 3
// 所有的位运算只会对小数起作用所以 3.1 | 0 会自动舍去小数部分达到取整效果
// 相当于 Math.floor(3.1);
```
###2.& 按位与运算符

a & b

运算规则：

0&0=0; 0&1=0; 1&0=0; 1&1=1; 即：a 与 b 的对应二进制位同时为“1”，结果才为“1”，否则为0.

```
console.log(3 & 4) // 0
console.log(31 & 2) // 2
```

###3.~ 取反运算符

~a

运算规则: 

将a按二进制位取反, 即将0变1, 1变0, 然后将二进制数变为浮点数

```js
console.log(~25) // -26
// 00000000000000000000000000011001 -> 11111111111111111111111111100110 -26
// 就像是将正数变负, 再取其反码
```

从表现上而言 ~ 是对数字求负, 然后减 1, 因此 25 变 -26.

###4.^异或运算符

a ^ b

运算规则: 

0^0=0; 0^1=1; 1^0=1; 1^1=0; a 和 b ，按二进制位进行“异或”运算。

> ^ 运算符满足如下运算规则
>+ 交换律：A^B=B^A
>+ 结合律：A^B^C=A^(B^C)=(A^B)^C
>+ 自反律：A^B^B=A^0=A
>+ X^X=0 ,X^0=X

```js
console.log(23^3) // 20
// 23 -> 00010111 3 -> 00000011 异或后为 00010100 -> 20
console.log(25.5^0) // 25
// 根据上面的说法, a^0 同样也能对 a 进行取整
```

### 5. << 左移运算符

a << b

运算规则: 

将a的各二进制位全部左移b位（左边的b个二进制位丢弃，右边补0）。

```js
console.log(3 << 2) // 12
// 3 -> 0011 运算结果为 1100 -> 12
```

就结果而言, 左移运算符 << 便是 a 乘上 2 的 b 次方

### 6. >> 右移运算符

运算规则: 

将a的各二进制位全部右移b位（右边的b个二进制位丢弃，若是正数, 左边补0, 若是负数则补1, 及补其符号位的数）。

```js
console.log(12 >> 2) // 3
console.log(12 >> 4) // 0
// 3 -> 0011 运算结果为 1100 -> 12
```

就结果而言, 右移运算符 << 便是 a 除以 2 的 b 次方, 若 2 的 b 次比 a 要大, 结果最小为 0

此时会有小伙伴问了, 普通整型是只有32位的, 如果 b 的值大于32或者小于0会怎么运算啊

那我们不妨来试试

```js
console.log(4 << 34) // 16
```

4 向左移位34位照理来说已经超出了原位数, 但是输出结果为16相当于左移两位 34 - 32 = 2, 
说到这应该明白了吧, 不过不清楚是走过了循环还是运行js的引擎自动将b%32

```js
console.log(4 << -30) // 16
```

其实看到这里也大概知道左移负数位的规则了吧, -30 + 32 = 2, 同样也是4 << 2 = 16


### 不同长度的数据进行位运算

>如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。
>
>我们知道在C语言(此处拿C举例, 毕竟JS没有long int之分..)中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行“与”运算，
>右端对齐后，左边不足的位依下面三种情况补足，
>+ 如果整型数据为正数，左边补16个0。
>+ 如果整型数据为负数，左边补16个1。
>+ 如果整形数据为无符号数，左边也补16个0。