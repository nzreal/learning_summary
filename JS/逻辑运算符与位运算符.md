# 逻辑运算符

## 1.&& 逻辑与

a && b

运算逻辑:

a && b, 若 a 为 false 则返回 a, 若 a 为 true 则返回 b

```js
console.log(3 && 1) // 1
console.log(0 && 1) // 0
// ps: 0为false
```

总结：假前真后

## 2.|| 逻辑或

a || b

运算逻辑:

a || b, 若 a 为 false 则返回 b, 若 a 为 true 则返回 a

```js
console.log(3 || 1) // 3
console.log(0 || 1) // 1
console.log('' || true) // true
// ps: ''空字符串在js中也会被判定为false
console.log(!!'') // false
```

总结：真前假后

## 3.! 逻辑非

!a

运算逻辑:

若 a 为 true, 则返回 false, 反之亦然

```js
console.log(!1) // false
```

若要显式的返回变量的布尔值则可以使用 !! 双重非运算符 来运算

```js
console.log(!!1) // true
console.log(!!0) // false
```

需要注意的是在 JS 中会被转换为 false 的表达式有:

- null
- undefined
- NaN
- 0
- 空字符串（"" or '' or ``)

总结: 取反

# 位运算符

> 其实位运算符是所有语言通用的运算符，偷懒起见还是写在了 JS 分类下哈哈哈

> 位运算符都需要将运算符前后的数转为二进制再运算, 所谓的位是二进制数的位数

## 1.| 按位或运算符

a | b

运算规则：

0|0=0；0|1=1；1|0=1；1|1=1；即: a 和 b 的对应二进制位只要有一个为 1，其值为 1。

```js
console.log(3 | 4) // 7
// 3转为二进制0011, 4转为二进制0100, 所以结果为0111, 输出7
console.log(31 | 2) // 31
// 31 -> 00011111 2 -> 00000010, 结果为00011111, 输出31
```

实际应用:

可用于小数取整

```js
//后面为0时取小于该小数的最大整数
console.log(3.1 | 0) // 3
// 所有的位运算只会对小数起作用所以 3.1 | 0 会自动舍去小数部分达到取整效果
// 相当于 Math.floor(3.1);
```

## 2.& 按位与运算符

a & b

运算规则：

0&0=0; 0&1=0; 1&0=0; 1&1=1; 即：a 与 b 的对应二进制位同时为“1”，结果才为“1”，否则为 0.

```
console.log(3 & 4) // 0
console.log(31 & 2) // 2
```

## 3.~ 取反运算符

~a

运算规则:

将 a 按二进制位取反, 即将 0 变 1, 1 变 0, 然后将二进制数变为浮点数

```js
console.log(~25) // -26
// 00000000000000000000000000011001 -> 11111111111111111111111111100110 -26
// 就像是将正数变负, 再取其反码
```

从表现上而言 ~ 是对数字求负, 然后减 1, 因此 25 变 -26.

## 4.^异或运算符

a ^ b

运算规则:

0^0=0; 0^1=1; 1^0=1; 1^1=0; a 和 b ，按二进制位进行“异或”运算。

> ^ 运算符满足如下运算规则
>
> - 交换律：A^B=B^A
> - 结合律：A^B^C=A^(B^C)=(A^B)^C
> - 自反律：A^B^B=A^0=A
> - X^X=0 ,X^0=X

```js
console.log(23 ^ 3) // 20
// 23 -> 00010111 3 -> 00000011 异或后为 00010100 -> 20
console.log(25.5 ^ 0) // 25
// 根据上面的说法, a^0 同样也能对 a 进行取整
```

## 5. << 左移运算符

a << b

运算规则:

将 a 的各二进制位全部左移 b 位（左边的 b 个二进制位丢弃，右边补 0）。

```js
console.log(3 << 2) // 12
// 3 -> 0011 运算结果为 1100 -> 12
```

就结果而言, 左移运算符 << 便是 a 乘上 2 的 b 次方

## 6. >> 右移运算符

运算规则:

将 a 的各二进制位全部右移 b 位（右边的 b 个二进制位丢弃，若是正数, 左边补 0, 若是负数则补 1, 及补其符号位的数）。

```js
console.log(12 >> 2) // 3
console.log(12 >> 4) // 0
console.log(-12 >> 2) // -3
console.log(-12 >> 5) // -1
// 此处 -12 >> 5 为 -1，因为负数是取其补码运算绝对值最小为 1 而，1000...0 是 -0 即 - 2 的 31 次方
```

就结果而言, 右移运算符 >> 便是 a 整除 2 的 b 次方, 若 2 的 b 次比 a 要大, 结果最小为 0

此时会有小伙伴问了, 普通整型是只有 32 位的, 如果 b 的值大于 32 或者小于 0 会怎么运算啊

那我们不妨来试试

```js
console.log(4 >> 34) // 1
console.log(4 << 34) // 16
```

4 向左移位 34 位照理来说已经超出了原位数, 但是输出结果为 16 相当于左移两位 34 - 32 = 2,
说到这应该明白了吧, 不过不清楚是走过了循环还是运行 js 的引擎自动将 b%32

```js
console.log(4 >> -30) // 1
console.log(4 << -30) // 16
```

其实看到这里也大概知道左移负数位的规则了吧, -30 + 32 = 2, 同样也是 4 << 2 = 16

## 7. >>> 无符号右移运算符

无符号在正数上表现均一致，而在负数上表现为无视符号位在符号位左侧补 0 ，且不取其源码直接显示

```js
console.log(-12 >>> 3) // 536870910
/**
 12 二进制为 1000,0000,0000,0000,0000,0000,0000,1100
 转为补码运算 1111,1111,1111,1111,1111,1111,1111,0100
 直接左补0  0001,1111,1111,1111,1111,1111,1111,1110
 即 2 的 29 次方 - 1 - 1
 536870910
**/
```

## 不同长度的数据进行位运算

> 如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。
>
> 我们知道在 C 语言(此处拿 C 举例, 毕竟 JS 没有 long int 之分..)中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行“与”运算，
> 右端对齐后，左边不足的位依下面三种情况补足，
>
> - 如果整型数据为正数，左边补 16 个 0。
> - 如果整型数据为负数，左边补 16 个 1。
> - 如果整形数据为无符号数，左边也补 16 个 0。

写到这可能有不少的小伙伴会问了: 逻辑运算就罢了, 位运算符乍一看很牛逼但实际有什么用呢?

诶, 这就问到点子上了, 作为一个前端切图仔, 我也不知道...(此处挖个坑日后来填 xixi)

哈哈哈别急, 一个是如上所述可以用于取余, 然后不得不搬出一道经典算法题 LeetCode231 2 的幂

对于要计算是否是 2 的幂次的数进行位运算 n & (n - 1) == 0 进行判断

p.s: 在我的算法中有详解哦

同时按位的左移右移>> << 是一个经典的解决用户权限等的方案，大家有兴趣可以自行搜索,也可以去了解一下 react 和 vue 的源码，里面也有将其用于作为判断属性的
